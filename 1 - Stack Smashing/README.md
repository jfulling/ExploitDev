![Intro slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img0.png)
## Abstract
This presentation is designed to introduce the concepts of exploits (focusing on memory corruption) to students just looking into getting a start into exploit development. It will, at a high level, cover the following topics

- What are the standard 32-bit CPU registers, and how do they work?
- How does the stack work in memory?
- What does a buffer overflow look like in the stack?
- What would you want to do in a buffer overflow?

---

![Tools slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img2.png)

## Tools

The tools used in this series are as shown in the above slide:

- Ubuntu 32-bit (12.04)
- GDB
- GCC
- Python/Perl scripting

---


![Registers slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img3.png)

## Registers

The following registers are mostly used in this series as general-purpose registers (especially as we develop our shellcode), but the key ones to pay attention to for this particular session are the **ESP**, **EBP** and **EIP** registers, as they have a clear purpose on traditional stack creation.

- EBP: Base pointer for the stack, signifies the beginning of the stack frame
- ESP: Pointer to a position on the stack
- EIP: Pointer to the next instruction to be executed

---

![Register breakdown slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img4.png)

## Register Breakdown

32-bit registers can be broken down into 4 logical units as shown in the above slide. We will use EAX as a sample register:

- EAX: A 32-bit register. Assigning a value to EAX will assign all 32 bits in the register (bits 0-31)
- AX: A 16 bit register. Assigning a value to AX will assign the first 16 bits in the register (bits 0-15)
- AH: An 8-bit register. Assigning a value to AH will assign the second 8 bits in the register (bits 8-15)
- AL: An 8-bit register. Assigning a value to AL will assign the first 8 bits in the register (bits 1-7)

---

![Stack frame slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/5.gif)

## Introduction to Stack Frames

In this series, a buffer overflow exploit achieves code execution by creating or modifying a stack frame. The above animation shows how a stack frame is created.

### Prologue 

When a function begins, the program will take the next instruction to execute (the point to resume execution after the function exits), and will push it to the top of the stack. Writing ESP to the stack advances ESP by 32 bits (since EIP is a 32-bit register).

Next, the current value of EBP is pushed to the stack, and the value of ESP is copied to EBP to keep track of the base of the current stack frame. This helps the program to keep track of where the function lives on the stack. When the function ends, the original EBP value (next to the EIP value pushed to the stack) is popped back into the EBP register, which helps the program keep track of where the parent function lives (which can include *main()*)

### Remaining steps

Additional values are pushed onto the stack as the function requires, such as parameters.

---

![Strcpy bug slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/6.gif)

## How a Buffer Overflow affects the Stack Frame

This slide demonstrates how a buffer overflow modifies the stack frame to achieve code execution.

Traditionally, in C, strings to be written and read are determined to have a fixed amount of space. However, a user may be able to write more characters than is allowed in the space allocated. The animation above shows what happens when a user passes too many letters into a function that does not validate user input.

If the user passes enough characters (in this case, the letter "A"), the allocated stack space will be overwritten as intended. However, since strcpy in this case is not being used with any validation, it will continue writing its input onto the stack, which will overwrite the *EBP* and *EIP* values pushed to the stack in the Prologue.

When the program continues its execution, and attempts to leave the function by returning to the EIP value written above the stored EBP value, it wil attempt to return to the overwritten value (in this case 0x41414141, where 41 is the hex value of "A").

0x41414141 is not a valid execution address, so the program execution will end in a segmentation fault.

This is important since we, as the user, can now supply input that will redirect the execution of the program. We can take advantage of this by using C, Python, or other languages to write raw hex values to the string, which will be interpreted as an address.

---

![Sample GDB overflow slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img7.png)

## Sample Overflow in GDB

This slide demonstrates what a successful buffer overflow looks like in GDB. Using the above process, there are a few things to keep track of on the stack.

- EBP value
- EIP value
- Length of the string buffer

Since the string reserves only 8 bytes, if we pass 8 "A"s, the string buffer would be filled as expected. However, our input string consists of 16 bytes, so based on the stack frame created, we will be overwriting EBP and EIP with their respective values.

Accordingly, EBP and EIP are overwritten with the expected values, and the program attempts to execute 0x43434343 (0x43 is the value of "C"), which is an invalid location for an instruction.

---

![Redirection slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img8.png)

## Redirecting Code Execution

Since we now know how to control EIP in this program, we can practice code redirection. In the previous slide, I took the same practice approach as *SecurityTube* by creating a function that is never called. But, by grabbing the base address of the function, (i.e. the Prologue of the function's stack frame), we can pass the addres 0x08048404 to the vulnerable function via raw hex bytes, and execute the function.

---

![Exploit slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img9.png)

## Putting it All Together

By using Python to print raw hex bytes, we can send a target address to the program and successfully exploit the vulnerability, by executing the function mentioned earlier.

Keep in mind that since we're exploiting a memory corruption bug on a Little-Endian x86 platform, we must write the least significant byte of the address first. Using Python, we can write raw hex bytes by using the "\xXX" notation, where XX is the byte we wish to write.

Since the target program is reading from STDIN, we can pipe the input into the program.

---

## References

A majority of this content was taken from Corelan and SecurityTube tutorials, check them out to learn more!

![References slide](https://github.com/jfulling/ExploitDev/blob/master/1%20-%20Stack%20Smashing/images/img10.png)
