![Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img0.png)

## Abstract

This slide deck serves to introduce students to the concept of manualy writing shellcode, and how it can be optimized for differing situations.

---

![What is Shellcode slide?](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img1.png)

## What is Shellcode?

In some circumstances, when an exploit occurs, an attacker can redirect code execution to an address where they have submitted user input. This code can perform a simple task (i.e. run `telnet towel.blinkenlights.nl`, or can be used to spawn a new shell in the context of that process.

In order for the CPU to execute user-input characters, the characters will represent raw assembly bytes (Operation Codes, or Op Codes). Often times, the amount of character input space will be limited, so shellcode has to be optimized for size. 

---

![Syscall slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img2.png)

## Syscalls

A quick way to write custom shellcode is to take advantage of syscalls available to the user. The file location `/user/include/i386-linux-gnu/asm/unistd32.h` contains a list of available syscalls and their syscall number in the unistd.h library. These syscalls often have `man` entries and documentation on how to use them.

---

![C to Assembly slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img3.png)

## How C Turns into Assembly

Using the above short program, we can see how exit(0) gets turned into assembly. Based on slide above, we can see that EAX contains the value of 0x1, which, in the previous slide, is the *exit* syscall.  EBX also contains the value 0, which, according to the documentation, is the return code for the exit function.

The `int 0x80` line, for the sake of this series, will execute the syscalls lined up in EAX.

---

![Switching to Shellcode slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img4.png)

## Under-the-Hood Assembly

In the above slide, the disassembly of the exit function is shown. It has three simple instructions, one to load the syscall into EAX, one to load the return code, and one to execute the syscall. Under normal conditions, we would be able to simply print the raw bytes into the string, but there are \x00 (null) bytes, which would prematurely terminate the string.

---

![Shellcode Patching slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img5.png)

## Patching the Shellcode

Since null bytes aren't acceptable in a string, we will have to change the way we pass the assembly into the buffer.

---

![Preparing New Shellcode slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img6.png)

## Preparing New Shellcode

Using the code in the above slide get a Proof-of-Concept that our approach will work, we will attempt to utilize the `execve` syscall with **`xterm`** as our reverse shell method. (Note: This will require some package installation on minimized installs)

---

![Execve Disassembly slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img7.gif)

## Disassembling Execve

The above disassembly shows how the Execve stack frame is structured with our syscalls. The animation walks through the following portions

1. The prologue and ESP stack alignment
2. Reserving the memory
3. Using offsets to store pointers to strings
4. Calling the function


---

![Diving into Execve slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img8.png)

## Execve Syscall Structure

The `execve` syscall takes 3 additional parameters (after setting EAX to the execve syscall):
1. The file name to be ran (full path): **/usr/bin/xterm**
2. Pointer to the argument list: stored in the *command* pointer
3. Pointer to environment configuration (e.g. environment variables). Since we are not using any in particular, it is okay to set EDX to null.

It is also possible to use GCC to print the assembly for the function via the **`-S`** flag. The assembly can be compiled with the **as** or **nasm** compilers, and linking it via **ld**.

---

![Execve Roadblocks slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img9.png)

## Execve Challenges

As shown in the previous stack animation, we were able to successfully leverage static memory addresses to read and write to. However, in an exploit, stack addresses to our strings are not always guaranteed. By taking a page out of the *Hacking: Art of Exploitation* book, we can use the **`jmp`** method to more reliably collect and call our shellcode.

---

![JMP Method slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img10.png)

## JMP Method

By using the *jmp* keyword, we can reference an automatic byte offset rather than trying to guess a static address. This can help reduce the number of null bytes in the shellcode, but there are still null bytes to take care of.

---

![Substituting Zero slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img11.png)

## Substituting Zeroes

Since we cannot directly insert a value of zero into our shellcode, we will have to get creative with our approach to writing it. A common method to achieve a reference-able zero is to **`xor`** a register against something of equal value. Since a register will always equal itself, we will always be able to xor a register with itself to clear it out.

Additionally, as shown in the previous slide deck, we can reference specific portions of the registers. Writing a value of 1 to EAX will write 0x00000001 to the register, which contains several null bytes. However, we can read from and write to specific portions of the EAX register, enabling us to minimzize the amount of zeroes being written (and the amount of space our shellcode uses).

In the above example, since we have zero-ed out ECX, we can copy bytes from the ECX register to the EBX register, granting us the ability to exit with a return code of 0.

However, we still have 1 null byte in our jmp command that needs to be addressed.

---

![Reverse Calling slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img12.png)

## Calling in Assembly

Since the `jmp` keyword cannot push variables onto the stack, we can use the **`call`** keyword to present more useful flow control. The call keyword will take the value below it and push it onto the stack, as shown in the slide above. The string "Hello, world!" is referenced in ECX by pushing it onto the stack via the *call* keyword, and immediately popped into ECX when in the HelloWorld function.

---

![Reverse Calling slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img13.png)

## Reverse Calling Method 

By placing the `call` keyword below the desired function, the null bytes in the original *call* opcodes will be set to higher values (i.e. 0xff), as it will be jumping a "negative" number of bytes into memory. (Think of how a negative number is stored as an integer - what is the unsigned value of -1?)

---

![Reverse Calling Bytes slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img14.png)

## Reverse Calling Method (contd.)

As shown, the two's complement principle is noticeable in the disassembly above. The 0x00 bytes are replaced with 0xff bytes.

---

![Saving Space](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img15.png)

## Using Characters to Save Space

With the XTerm shell, we will push direct strings onto the stack and establish pointers to them, and reference the pointers during code execution. A python one-liner can be used to convert characters to little endian hex bytes.

`python -c 'print "ABCD"[::-1].encode("hex")'`

Which can be broken down as follows:

`print "ABCD"[::-1]` Prints the string "ABCD" starting from the first letter, progressing one letter at a time, but in the reverse order.

`.encode("hex")` Converts the letters into hex values

---

![Path Buffering](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img16.png)

## Path Buffering

As shown in *SecurityTube*'s tutorials, it is in most cases possible to abuse string interpretation to provide a buffer that enables us to fit our string into an even value that fits appropriately in the string buffer.

In the above slide, we are unable to divide `/usr/bin/xterm` by 4, and the remainder of the string will contain null bytes. However, if we add extra forward slashes to the path, they will be ignored, but we can then expand our string to 16 bytes, which will prevent a null byte from being inserted.

---

![Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img17.gif)

## Putting it all Together

The above animation shows how to combine some of the previously mentioned concepts to make useable shellcode.

Note: Shortly after I finished developing this, I found similar code [here on ExploitDB](https://www.exploit-db.com/exploits/40110) and applied some of the fixes they had to reduce size.

Keep in mind that since the stack grows down in memory, we will be pushing things backwards.

1. We gather a zero value in EAX to use it as a terminator for strings, and to clean it up for the execve call
2. We are going to push a string onto the stack, so we need a null terminator. We push the value of EAX, then the raw bytes for the string. We assign EBX as a pointer to the /usr/bin///xterm string.
3. Similar to the last step, we push our null byte first. Since we are okay to call the Environment configuration null on Execve, we can point EDX to a null value.
4. Since we've already pushed a null byte, we are okay to continue pushing the next string and assigning ESI to the string.
5. Repeat the process of pushing a null byte and a string, assigning EDI to the string.
6. Now that all of our arguments are on the stack, ECX needs to point to the argument array. We push a null byte to the stack to signify the end of the array, and then push our strings in reverse order, so when the stack is read upwards, the xterm shell makes sense. Finally, load ESP into ECX so ECX is pointing to the beginning of our xterm shell array.
7. Now that EBX points to the executable, ECX points to the argument array, and EDX points to a (null) environment configuration, and EAX is already zero-ed out, we can safely set AL to a value of 11 (execve).

---

![PoC slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img18.png)

## Proof of Concept

The above slide shows the opcodes of our shellcode, and there are no null bytes. 

We execute the shellcode, and if we have our firewall configuration and XNest server running, we will get a reverse shell!

---

![Privilege Re-Escalation slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img19.png)

## Privilege Re-Escalation

In *Hacking: The Art of Exploitation*, the author mentions that sometimes there are cases when programs will assign lower privileges mid-execution to prevent unauthorized access, even though the program is running in a privileged state. By getting creative with our shellcode, we can call the `setresuid` and `setresgid` values to re-set our privileges!

Note that this is not necessarily a privilege escalation guarantee as much as it is an example of how to get creative with shellcode.

---


![References slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/2%20-%20Shellcode%20Authoring/images/img20.png)

## References

This slide deck was largely inspired from the *Hacking: The Art of Exploitation* book, corelan tutorials, and *SecurityTube* tutorials. To learn more, go check them out!
