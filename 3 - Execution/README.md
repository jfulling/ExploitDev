![Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img0.png)
## Abstract

Now that the fundamentals of stack smashing and shellcode development are covered, it follows that executing shelcode be explored next.

---

![Testing Execution slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img1.png)

## Testing Execution

After writing an assembly program and eliminating unacceptable null bytes, we can use this command line snippet grabbed from *![commandlinefu.com](https://www.commandlinefu.com/commands/browse)* to grab the opcodes from the compiled program, and turn it into insertable shellcode.

Once generated, the shellcode string can be inserted into a C file, and the following code will enable the shellcode to be interpreted as raw instructions.

```
char shellcode[] = "\x01\x02\x03..." //shellcode, global variable

int *ret; //Create an unitialized integer pointer

ret = (int *)&ret +2; // Take the address of ret (reinterpreted as an int type)
                      // and add two to it (2 * 1 int, so 8 bytes), and assign
                      // that value back to ret.

(*ret) = (int)shellcode; // Set ret equal to the pointer of an array, and assign
                         // it the shellcode re-casted as an int type
 ```                        
This method is an interesting approach to executing shellcode. Remember in the first slide deck (Smashing the Stack) that all functions have stack frames, which, for our purposes, have the same prologue of pushing EIP and EBP, and `main()` is no exception. 

After the stack frame is created, we create the *ret* int pointer, which makes it the next item on the stack. In the next line, we tell the program to take the pointer for *ret* and add 2 (int) units to it, which is 8 bytes. Remember that the stack grows downwards, so what is happening is that our *ret* pointer is going the wrong direction, and up the stack past EBP and EIP.

Now that we're overwriting the `main()` stack frame (in a similar fashion to the stack smashing approach), we simply tell the program to set the int array pointer (*ret*) to point to an (int-typecasted) shellcode array.

So how does this achieve execution? Once the `main()` stack frame closes out, it will return execution to the original EIP set to the top of the stack frame. However, since we've overwritten the `main()` EIP pointer, we are now executing our shellcode at the end of the program.

A more detailed explanation ![can be found here.](http://disbauxes.upc.es/code/two-basic-ways-to-run-and-test-shellcode/)

---


![Vulnerable code slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img2.png)

## Sample Vulnerable Program

In this slide exists a very simple buffer overflow vulnerability. The program will read a parameter passed to it via argc, and will copy it into a 128-byte buffer. We will be using a similar approach described above and dissecting it over the next few slides.


---

![Vulnerable layout slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/3.gif)

## Vulnerable Code: Layout

The above animation shows how the payload for code execution will need to be structured.

Since strcpy does not check how many bytes are being written to its destination, we will want to pass enouch bytes to the buffer to fill it, and overwrite stack elements past it. The animation below shows our shellcode being written to the buffer, then filler characters after ("junk" chars),then an address (to overwrite the RET address) that points to our shellcode.

However, the challenge this provides is that we will need to consistently locate the exact starting address of our shellcode. This issue will be addressed in the next slide.

---

![Finding shellcode slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/4.gif)

## Finding the Shellcode

In some cases, shellcode can be placed in an evironment variable, which can be referenced outside of the program, which can potentially provide a program-agnostic location that can easily be remembered.

In this animation, the program shows how to craft an "EGG" environment variable that can be used against the vulnerable program shown earlier.

## NOP Slides (Sleds)

In some cases where the exact starting address may not be known (but a short range around that address is known), writing the \x90 byte in the place of junk characters may provide a practical advantage. The \x90 byte, or No-Operation (NOP) byte simply tells the CPU to do nothing and progress to the next instruction.

When several of these bytes are lined up next to each other before the shellcode, the range of acceptable addresses to jump to expands dramatically. Now, instead of jumping directly to the starting address of the shellcode, we can jump to any address containing one of the NOP bytes we provided, and the CPU will continue executing the NOP bytes until it reaches our shellcode, thus creating the concept of a "slide" into our shellcode.

---

![Finding Shellcode GDB slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img5.png)

## Locating the Shellcode in GDB

Using GDB to to inspect the environment variable, we can see exactly how the shellcode overwrites what's currently being stored. By setting the address to 0xdeadbeef, we can easily confirm that we've overwritten the return address, and just need to look at GDB to see where we should set our new pointer to in order to execute our shellcode.

**Note:** If we had placed the nop sled before the shellcode (instead of after), we could set the pointer to point to any 0x90909090 block and still achieve successful execution.

Based on the screenshots below, in order to reference our shellcode via the environment variable, the return address needs to point to `0xbffff1c8`.

**Note:** Similar exercises are practiced on the exploit-exercises *Protostar* VM I hihgly recommend them to get more hands-on experience with performing stack overwrites and other memory corruption exploits!

---

![Finished Exploit slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img6.png)

## Finished Exploit

By updating the return address, we can see successful code execution, with a launched XTerm shell.

However, this exploit method is very old, and kernel securities have since been introduced to prevent code execution like this. Two of the ones that this series will cover are ASLR and DEP:

* ASLR: Address Space Layout Randomization - This kernel security feature randomizes (to an extent) the base address of a program, while keeping the offsets the same. Since the base address is randomized, it no longer becomes possible to guarantee a consistent return address for shellcode on every program execution instance.

* DEP/NX: Data Execution Prevention / Non-Executable Stack - Since the stack primarily serves as an organized way to pass parameters and other data to functions, there is no reason that it should be used as a place to store executable code (which is ultimately the feature we've been exploiting for this series up until now). DEP will mark the stack ranges of memory as non-executable, and memory in these regions will not be permitted to have its data referenced as executable code by EIP.

---

![Bypassing DEP/NX slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img7.png)

## Bypassing DEP/NX

In some cases it is possible to bypass DEP with a round-about way of referencing code. The below approaches can be used, and will be covered more in the fifth presentation of this series.

* ROP: Return-Oriented Programming: This bypass method is compliant with the use cases of the stack, as it consists of addresses to other locations in memory. However, ROP takes advantage of the `return` function in assembly, as it will pop the next address off the stack and return to it after completion.

In the program memory space (or in some loaded library spaces), a user can search for a series of instructions followed by `return` opcodes. A user will be able to take an address to these short instruction series ("ROP gadgets") and place it on the stack.

How does this achieve code execution? EIP will execute the instructions stored at the address, and will return to the next address. By stringing many of these ROP gadgets together, shellcode can be created indirectly.

* Function Calling: In some cases (i.e. cracking software), code execution is not always the desired result. It may suffice to just call another function within the program (e.g. to bypass a spam-email requirement from a program).

* Ret2LibC: This will not be covered in this presentation series, but in several cases, a user can return to the LibC functions and achieve code execution by referencing already included functions.

---

## References

The majority of content from this presentation is taken from _SecurityTube_, *Hacking, The Art of Exploitation*, *Shellcoder's Handbook*, and some exploit-exercises protostar challenges.

![Exploit slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/3%20-%20Execution/images/img8.png)
