![Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img0.png)

## Abstract

In most cases now, a vanilla stack overwrite as shown in the previous presentations won't be successful due to kernel securities mentioned in the previous deck. 

Another vulnerability that can be exploited is known as a *String Formatting* bug. With the `printf` function, there is a common notation for printing strings. When improperly handled, the string can be interpreted literally, granting the end user the ability to insert `printf` functionality into a string.

---

![Stack Canaries slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img1.png)

## Stack Canaries

An additional security measure that can be applied against stack-based overwrite attacks is known as a *Stack Canary*. A stack canary is a value that is placed at the end of a stack frame, that, if modified, signals an anomaly and halts execution.

The value is treated simply as a value, and is not interpreted as an address or a set of instructions. Notice that in all 4 examples of the program execution, the stack canary ends with a value of \x00, meaning that, even if the stack canary was calculated, it could not be inserted into an exploit string, as it would terminate the input string.

---


![Printf Modifiers slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/2.gif)

## Format String Modifiers

In C, the `printf` function function supports several values denoting how to handle specific pieces of data. The printf function will push items onto the stack, and then pop them off, displaying them as the type denoted by the modifier.

The animation in the above slide shows an example on how how printf works.

---

![Continuous reading slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img3.png)

## Continuous Stack Reading

The `printf` function does not verify what it reads or writes to the stack. This can be shown via the `%x` modifier, which reads the the next value of the stack and interprets it as a hex value. This can be used to read ("leak") extra information from the stack by lining up several `%x` modifiers.

---

![Improper Handling slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img4.png)

## Improper String Handling

This functionality can be exploited when a string is directly referenced by `printf`. When no string modifiers are used, the string will be handled literally, as it is the first parameter of the `printf` function, which is expected to contain modifiers.

---

![Improper String Handling continued slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img5.png)

## Improper String Handling - Exploitation

The above slide shows an example of a program that properly and improperly handles the string in `printf`. In the improper way of printing the string, the second screenshot shows the a hex value being read from the stack.

---

![Leaking Memory slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img6.png)

## Using Python to Leak Memory

Using Python to generate several `%x` strings, it is possible to leak several bytes off the stack until the input string is recovered. Using this method, we can find where on the stack our user input can be found.

---

![R/W on the Stack slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img7.png)


## Reading and Writing on the Stack

The `printf` function has a %n modifier, which takes the number of bytes written so far and writes it to the current location on the stack. 

So now that we have a method to leak a memory address and write bytes to an address, we are going to target a function used in a sample program, and overwrite the `putchar` function.

---

![Directly Accessing Stack Values slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img8.png)

## Directly Accessing Stack Values

In C, it is not always necessary to print multiple `%x` modifiers. Instead the **$** operator can be used.

In the above slide, it can be used to print the 11th value off the stack, giving a neater output.

---

![Sample Exploitation slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img9.png)

## Sample Exploitation

In this slide, an address is pushed onto the stack, and by using the offset calculated in the previous slides, we can begin writing to that address.

The function stored at 0x08404a018 (`putchar`) is pushed onto the stack via the string, and the `%n` modifier is used to take the current number of written bytes and write it to that address.

Thus, when the `putchar` function is called, EIP gets sent to addres 0x00000004, since only 4 bytes have been printed before the `%n`.

By using this method, we can control the program flow via redirection.

---

![Redirecting a Function slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img10.png)

## Continuing the Exploit

The approach in this presentation covers format string exploitation by writing the target address two bytes at a time. In order to accomplish this, the address of our hidden function must be stored in 0x0804a018.

The `%u` modifier is a way to print an unsigned value, which will take up one byte of output. So, since we are first writing the lower half of our target address, we must take the two addresses already written in the input string (8 bytes), and subtract that from 0x84c4 to get the remaining number of bytes needed (33980). In the above slide, it is shown that this gets is to 0x000084c4, which is a good start.

However, 0x0804 is a siginificantly smaller value than 0x84c4, and we are unable to un-write bytes to the buffer. This presents a challege for writing a complete address.

---

![Finishing the exploit slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/4%20-%20String%20Formatting/images/img11.png)

## Finished exploit

Although 0x84c4 is greater than 0x0804, we can solve this issue by introducing a carry (think of basic addition). What we can do is write 0x10804 bytes to the output, but since this is strictly a 32-bit system, the carried 1 will be dropped, enabling us to write the initial 0x0804 bytes to the function.

As shown in the slide, this enables us to call our secret function.
