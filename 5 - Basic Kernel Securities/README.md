![Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img0.png)
## Abstract

This presentation serves to explore some of the early kernel securities, and dive into how DEP/NX can be bypassed by diving into the concept of ROP chains.

---

![Recap slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img1.png)

## DEP/NX

As referenced an earlier presentation, *DEP/NX* is a security measure that prevents data on the stack from being treated as executable instructions. It ensures that the executable bit for the memory in the stack regions is not set, so when the execution flow gets sent to the stack, the execution will end with a segfault.

Two methods that can be used to continue code execution with a non-executable stack are Return-Oriented Programming, or Return-to-Libc. This presentation focuses on the Return-Oriented Programming (ROP) method.

---


![ROP Intro slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img2.png)

## Introduction to ROP

Instead of writing your own raw shellcode to the stack, ROP enables a user to string together pre-existing segments of code (in linked libraries and the program itself). By continuously returning to different code segments, a user can augment shellcode to achieve code execution.

A useful analogy for ROP is a note written from cut-and-pasted magazine letters. While the author did not write the individual letters, they were able to create a message by stringing together pre-existing letters.

---

![ROP Gadgets slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img3.png)

## ROP Gadgets

In order to string together the code snippets, it is critical that the `ret` keyword is used. This is because the `ret` command will be able to continue execution flow by going to the next address on the stack.

Several tools exist that will analyze the compiled code of a program and return a list of instructions followed by a `ret` keyword, and the address they're stored at. When attempting to use ROP as a bypass, a user can simply string together these addresses to perform code execution.

---

![ROP Overflows slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img4.png)

## ROP Overflows

Using this screengrab from a YouTube video (that I have unfortunately been unable to find since), a successful ROP chain can be shown on the stack.

---

![ROP Exploit Code slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img5.png)

## ROP Exploit Code

In the same video, the author showcases how Python can easily string together ROP gadgets on the stack to emulate shellcode. This shellcode will clear EAX, and set it to 11 (the `Execve` syscall) by calling the same `inc eax; ret` gadget 11 times. Then it will call `execve` via the `int 0x80` interrupt.

![ROP  Mitigation slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img6.png)

## ROP Mitigation: ASLR

As mentioned in an earlier presentation, the Address Space Layout Randomization security feature randomizes the base address of the program, which makes using static addresses unreliable. Since we are unable to reference ROP gadgets by their static addresses when ASLR is enabled, we are presented with a challenge.

---

![Bypassing ASLR slide](https://raw.githubusercontent.com/jfulling/ExploitDev/master/5%20-%20Basic%20Kernel%20Securities/images/img7.png)

## Bypassing ASLR

There are a few ways an attacker can circumvent ASLR:
* Brute-Force Attacks: In some cases (i.e. 32-bit systems) a user can run a program repeatedly until the hardcoded addresses line up with the randomly-generated program base address. This is generally unreliable and a bad idea.
* Addres Disclosure Vulnerabilities: Somtimes, an vulnerability in a program can be exploited to reveal memory addresses that can enable a user to successfully calculate the address of their desired ROP gadgets
* Non-ASLR Compliant Libraries: While the kernel is able to randomize the base address of a program at execution, not all libraries linked to the program will be able to provide the same functionality. In these cases, a user can reliably use ROP gadgets in these libraries to string together an exploit.
